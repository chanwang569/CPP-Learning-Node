# 1. 前言

C++ 的两个关注：

- **语言结构到硬件设备的直接映射**
- **零开销抽象**
  - 你不用的东西，你就不需要付出代价（“没有散落在各处的赘肉”）。
  - 你使用的东西，你手工写代码也不会更好。
  
## 1.1 年表

- 1979 年：工作始于“带类的 C”，它变成了 C++；拥有了第一个非研究性的用户；
  - 语言：`class`、构造函数/析构函数、`public`/`private`、简单继承、函数参数类型检查
  - 库：`task`（协程和仿真支持）、用宏参数化的 `vector`
- 1985 年：C++ 的首次商业发行；TC++PL1 [Stroustrup 1985b]
  - 语言：`virtual` 函数、运算符重载、引用、常量
  - 库：`complex` 算法，流输入输出
- 1989–91 年：ANSI 和 ISO 标准化开始；TC++PL2 [Stroustrup 1991]
  - 语言：抽象类、多重继承、异常、模板
  - 库：输入输出流（但没有 `task`）
- 1998 年：C++98、第一个 ISO C++ 标准 [Koenig1998]、TC++PL3 [Stroustrup 1997]
  - 语言：`namespace`、具名类型转换[^1]、`bool`、`dynamic_cast`
  - 库：STL（容器和算法）、`string`、`bitset`
- 2011 年：C++11 [Becker 2011]，TC++PL4 [Stroustrup 2013]
  - 语言：内存模型、`auto`、范围 `for`、`constexpr`、lambda 表达式、用户定义字面量……
  - 库：`thread` 和锁、`future`、`unique_ptr`、`shared_ptr`、`array`、时间和时钟、随机数、无序容器（哈希表）……
- 2014 年：C++14 [du Toit 2014]
  - 语言：泛型 lambda 表达式、`constexpr` 函数中的局部变量、数字分隔符……
  - 库：用户定义字面量……
- 2017 年：C++17 [Smith 2017]
  - 语言：结构化绑定、变量模板、模板参数的构造函数推导……
  - 库：文件系统、`scoped_lock`、`shared_mutex`（读写锁）、`any`、`variant`、`optional`、`string_view`、并行算法……
- 2020 年：C++20 [Smith 2020]
  - 语言：`concept`、`module`、协程、三路比较、改进对编译期计算的支持……
  - 库：概念、范围、日期和时区、`span`、格式、改进的并发和并行支持……

# 2. 背景：C++ 的 1979–2006

## 2.1 第一个十年

始于 1979 年 4 月，名为**带类的 C**。

“new 函数”和“delete 函数”这两个术语是“构造函数”和“析构函数”的原始术语。直到今天，我仍然认为构造函数和析构函数是 C++ 的真正核心。

1982 年，在看到让函数参数检查保持可选的效果后，我将其设为强制的

为了能够理性思考 C++ 的成长，我想出了一套设计规则。这些在 [Stroustrup 1993, 1994] 中有介绍，所以这里我只提一小部分：

> - 不要陷入对完美的徒劳追求。
> - 始终提供过渡路径。
> - 说出你的意图（即，能够直接表达高层次的思路）。
> - 不要隐式地在静态类型系统方面违规。
> - 为用户定义类型提供和内置类型同样好的支持。
> - 应取消预处理器的使用。
> - 不要给 C++ 以下的低级语言留有余地（汇编语言除外）。

- **1981 年**：`const`——支持接口和符号常量的不变性。
- **1982 年**：虚函数——提供运行期多态。
- **1984 年**：引用——支持运算符重载和简化参数传递。
- **1984 年**：运算符和函数重载——除了算法和逻辑运算符外，还包括：允许用户定义 `=`（赋值）、`()`（调用；支持函数对象（[§4.3.1](04.md#431-lambda-表达式)））、`[]`（下标访问）和 `->`（智能指针）。
- **1987 年**：类型安全链接——消除许多来自不同翻译单元中不一致声明的错误。
- **1987 年**：抽象类——提供纯接口。

在 1980 年代后期，随着计算机能力的急剧增强，我对大型软件更感兴趣，并做了如下补充：

- 模板——在经历了多年使用宏进行泛型编程的痛苦之后，更好地支持泛型编程。
- 异常——试图给混乱的错误处理带来某种秩序；RAII（[§2.2.2](#222-标准库组件)）便是为此目标而设计的。
  
> C++ 是一门偏向系统编程的通用编程语言，它是
>
> - 更好的 C
> - 支持数据抽象
> - 支持面向对象编程
> - 支持泛型编程

## 2.2 第二个十年

ANSI C++ 委员会是 1989 年 12 月在华盛顿特区的一次会议上成立的

经过了惯例性的、大约十年的工作，该委员会终于发布了第一个标准：C++98。

### 2.2.1 语言特性

C++98 的主要语言特性是

- 模板——无约束的、图灵完备的、对泛型编程的编译期支持，在我早期工作（[§2.1](#21-第一个十年)）的基础上进行了许多细化和改进；这项工作仍在继续（[§6](06.md#6-概念)）。
- 异常——一套在单独（不可见的）路径上返回错误值的机制，由调用方栈顶上的“在别处”的代码处理；见（[§7](07.md#7-错误处理)）。
- `dynamic_cast` 和 `typeid`——一种非常简单的运行期反射形式（“运行期类型识别”，又名 RTTI）。
- `namespace`——允许程序员在编写由几个独立部分组成的较大程序时避免名称冲突。
- 条件语句内的声明——让写法更紧凑和限制变量作用域。
- 具名类型转换——（`static_cast`、`reinterpret_cast` 和 `const_cast`）：消除了 C 风格的类型转换中的二义性，并使显式类型转换更加显眼。
- `bool`：一种被证明非常有用和流行的布尔类型；C 和 C++ 曾经使用整数作为布尔变量和常量。

RAII 代码不同于传统的函数使用，它允许在库中一劳永逸地定义“清理内存”，而不是程序员每次使用资源时都必须记住并显式编写。至关重要的是，正确和健壮的代码更简单、更短，并且至少与传统风格一样高效。在接下来的 20 年里，RAII 已遍布 C++ 库。

### 2.2.2 标准库组件

C++98 标准库提供了：

- STL——创造性的、通用的、优雅的、高效的容器、迭代器和算法框架，由 Alexander Stepanov 设计。
- 特征（trait）——对使用模板编程有用的编译期属性集（[§4.5.1](04.md#451-实现技巧)）。
- `string`——一种用于保存和操作字符序列的类型。字符类型是一个模板参数，其默认值是 `char`。
- `iostream`——由 Jerry Schwartz 和标准委员会精心制作，基于我 1984 年的简单的数据流，处理各种各样的字符类型、区域设置和缓冲策略。
- `bitset`——一种用于保存和操作比特位集合的类型。
- `locale`——用来处理不同文化传统的精致框架，主要与输入输出有关。
- `valarray`——一个数值数组，带有可优化的向量运算，但遗憾的是，未见大量使用。
- `auto_ptr`——早期的代表独占所有权的指针；在 C++11 中，它被 `shared_ptr`（共享所有权）和 `unique_ptr`（独占所有权）（[§4.2.4](04.md#424-资源管理指针)）替代。

毫无疑问，STL 框架是最为重要的标准库组件。我认为可以说，STL 和它开创的泛型编程技术挽救了 C++，使它成长为一种有活力的现代语言。

## 2.3 C++ 的 2006

在《C++ 程序设计语言（第三版）》[Stroustrup 1997] 中，我引用了尼科洛·马基雅维利（Niccolò Machiavelli）的话：
> 没有什么比开创一种新秩序更难于推行、更让人怀疑能否成功、处理起来更加危险。因为改革者会与所有从旧秩序中获利的人为敌，而所有从新秩序中获利的人却只是冷淡的捍卫者。

## 2.4 其他语言

下面是其他语言在二十一世纪对 C++ 的某些真实或假想的影响：

- `auto`——从初始化器推断类型的能力。它在现代语言中很流行，但也已由来已久。我不知它的最早起源，但我在 1983 年实现这个功能的时候，也并不认为它很新颖（[§4.2.1](04.md#421-auto-和-decltype)）。
- `tuple`——许多语言，特别是源自函数式编程传统的语言，都有元组，它通常是一个内置类型。C++ 标准库 `tuple` 及其许多用法都从中受到启发。`std::tuple` 派生自 `boost::tuple` [Boost 1998–2020]（[§4.3.4](04.md#434-tuple)）。
- `regex`——加入 C++11 的标准库 `regex` 是（经由 Boost；已致谢）从 Unix 和 JavaScript 的功能中拷贝来的（[§4.6](04.md#46-c11标准库组件)）。
- 函数式编程——函数式编程特性和 C++ 构造之间有许多明显的相似之处。大多数不是简单的语言特性，而是编程技巧。STL 受到函数式编程的启发，并首先在 Scheme [Stepanov 1986] 和 Ada [Musser and Stepanov 1987] 中进行了尝试（未成功）。
- `future` 和 `promise`——源自 Multilisp，经由其他 Lisp 方言（[§4.1.3](04.md#413-期值future)）。
- 范围 `for`——许多语言中都有对应物，但直接启发来自 STL 序列（[§4.2.2](04.md#422-范围-for)）。
- `variant`、`any` 和 `optional`——显然受到多种语言的启发（[§8.3](08.md#83-variantoptional-和-any)）。
- lambda 表达式——显然，部分灵感来自于函数式语言中 lambda 表达式的应用。但是，在 C++ 中，lambda 表达式的根源还可以上溯到 BCPL 语言中用作表达式的代码块、局部函数（多次被 C 和 C++ 拒绝，因其容易出错且增加了复杂性）和（最重要的）函数对象（[§4.3.1](04.md#431-lambda-表达式)）。
- `final` 和 `override`——用于更明确地管理类层次结构，并且在许多面向对象的语言中都可以使用。在早期的 C++ 中已经考虑过它们了，但当时被认为是不必要的。
- 三向比较运算符 `<=>`，受 C 的 `strcmp` 及 PERL、PHP、Python 和 Ruby 语言的运算符的启发（[§9.3.4](09.md#934-)）。
- `await`——C++ 里最早的协程（[§1.1](01.md#11-年表)）受 Simula 启发，但是作为库提供，而不是作为语言特性，这是为了给其他替代的并发技术留出空间。C++20 中的无栈协程的思想主要来自 F#（[§9.3.2](09.md#932-协程)）。

同样，C++ 对其他语言的贡献也难以估量。通常，类似的特性是平行演化的，或有着共同的根源。例如：

- Java 和 C# 中的泛型——他们采用了其他语言的泛型模式，但采用了 C++ 语法，并且是在 C++ 大规模展示了泛型编程的用途之后，才添加泛型。
- Java、Python 等的资源弃置惯用法（dispose idiom）——这大致是在垃圾收集语言中最能接近析构函数的做法了。
- D 编程语言进行编译期求值——我向 Walter Bright 解释了早期的 constexpr 设计。
- C++ 基于构造函数和析构函数的对象生存期模型是 Rust 灵感的一部分。好笑的是，最近 C++ 经常被指责从 Rust 那里借用了这种想法。
- C 采用了 C++11 的内存模型、函数声明和定义语法、以声明为语句、`const`、`//` 注释、`inline` 以及 `for` 循环中的初始化表达式。

C++ 与其他语言之间的许多差异源于 C++ 对析构函数的使用。这使得垃圾收集的语言很难直接从 C++ 借用。

# 4. C++11：感觉像是门新语言


C++11 引入了大量令人眼花缭乱的语言特性，包括：

- 内存模型——一个高效的为现代硬件设计的底层抽象，作为描述并发的基础（[§4.1.1](#411-内存模型)）
- `auto` 和 `decltype`——避免类型名称的不必要重复（[§4.2.1](#421-auto-和-decltype)）
- 范围 `for`——对范围的简单顺序遍历（[§4.2.2](#422-范围-for)）
- 移动语义和右值引用——减少数据拷贝（[§4.2.3](#423-移动语义)）
- 统一初始化—— 对所有类型都（几乎）完全一致的初始化语法和语义（[§4.2.5](#425-统一初始化)）
- `nullptr`——给空指针一个名字（[§4.2.6](#426-nullptr)）
- `constexpr` 函数——在编译期进行求值的函数（[§4.2.7](#427-constexpr-函数)）
- 用户定义字面量——为用户自定义类型提供字面量支持（[§4.2.8](#428-用户定义字面量)）
- 原始字符串字面量——不需要转义字符的字面量，主要用在正则表达式中（[§4.2.9](#429-原始字符串字面量)）
- 属性——将任意信息同一个名字关联（[§4.2.10](#4210-属性)）
- lambda 表达式——匿名函数对象（[§4.3.1](#431-lambda-表达式)）
- 变参模板——可以处理任意个任意类型的参数的模板（[§4.3.2](#432-变参模板)）
- 模板别名——能够重命名模板并为新名称绑定一些模板参数（[§4.3.3](#433-别名)）
- `noexcept`——确保函数不会抛出异常的方法（[§4.5.3](#453-noexcept-规约)）
- `override` 和 `final`——用于管理大型类层次结构的明确语法
- `static_assert`——编译期断言
- `long long`——更长的整数类型
- 默认成员初始化器——给数据成员一个默认值，这个默认值可以被构造函数中的初始化所取代
- `enum class`——枚举值带有作用域的强类型枚举

以下是主要的标准库组件列表（[§4.6](#46-c11标准库组件)）：

- `unique_ptr` 和 `shared_ptr`——依赖 RAII（[§2.2.1](02.md#221-语言特性)）的资源管理指针（[§4.2.4](#424-资源管理指针)）
- 内存模型和 `atomic` 变量（[§4.1.1](#411-内存模型)）
- `thread`、`mutex`、`condition_variable` 等——为基本的系统层级的并发提供了类型安全、可移植的支持（[§4.1.2](#412-线程和锁)）
- `future`、`promise` 和 `packaged_task`，等——稍稍更高级的并发（[§4.1.3](#413-期值future)）
- `tuple`——匿名的简单复合类型（[§4.3.4](#434-tuple)）
- 类型特征（type trait）——类型的可测试属性，用于元编程（[§4.5.1](#451-实现技巧)）
- 正则表达式匹配（[§4.6](#46-c11标准库组件)）
- 随机数——带有许多生成器（引擎）和多种分布（[§4.6](#46-c11标准库组件)）
- 时间——`time_point` 和 `duration`（[§4.6](#46-c11标准库组件)）
- `unordered_map` 等——哈希表
- `forward_list`——单向链表
- `array`——具有固定常量大小的数组，并且会记住自己的大小
- emplace 运算——在容器内直接构建对象，避免拷贝
- `exception_ptr`——允许在线程之间传递异常

## 4.1 C++11：并发支持

### 4.1.1 内存模型

最紧迫的问题之一，是在一个有着多核、缓存、推测执行、指令乱序等的世界里精确地规定访问内存的规则。

基本上，C++11 模型基于**之前发生（happens-before）关系** [Lamport 1978]，并且既支持宽松的内存模型，也支持顺序一致 [Lamport 1979] 的模型。在这些之上，C++11 还提供了对原子类型和无锁编程的支持，并且与之集成。 

C++11 引入了 `atomic` 类型，上面的简单操作都是原子的：

```cpp
atomic<int> x;
void increment()
{
    x++;  // 不是 x = x + 1
}
```

显然，这些都是广泛有用的。例如，使用原子类型使出名棘手的双重检查锁定优化变得极为简单：

```cpp
mutex mutex_x;
atomic<bool> init_x;  // 初始为 false
int x;

if (!init_x) {
    lock_guard<mutex> lck(mutex_x);
    if (!init_x) x = 42;
    init_x = true ;
}  // 在此隐式释放 mutex_x（RAII）

// ... 使用 x ...
```

双重检查锁定的要点是使用相对开销低的 `atomic` 保护开销大得多的 `mutex` 的使用。

`lock_guard` 是一种 RAII 类型（[§2.2.1](02.md#221-语言特性)），它确保会解锁它所控制的 `mutex`。

### 4.1.2 线程和锁

C++ 对线程和锁级别编程的支持是 POSIX 和 Windows 所提供的线程和锁的类型安全变体。在 [Stroustrup 2013] 有所描述，在 Anthony Williams 的书 [Williams 2012, 2018] 中有更为深入的探讨：

- `thread`——系统的执行线程，支持 `join()` 和 `detach()`
- `mutex`——系统的互斥锁，支持 `lock()`、`unlock()` 和保证 `unlock()` 的 RAII 方式
- `condition_variable`——系统中线程间进行事件通信的条件变量
- `thread_local`——线程本地存储

```cpp
class F {  // 传统函数对象
public:
    F(const vector<double>& vv, double* p) : v{vv}, res{p} { }
    void operator()();        // 将结果放入 *res
private:
    const vector<double>& v;  // 输入源
    double* res;              // 输出目标
};

double f(const vector<double>& v);  // 传统函数

void g(const vector<double>& v, double* res); // 将结果放入 *res

int comp(vector<double>& vec1, vector<double>& vec2, vector<double>& vec3)
{
    double res1;
    double res2;
    double res3;
    // ...
    thread t1 {F{vec1,res1}};            // 函数对象
    thread t2 {[&](){res2=f(vec2);}};    // lambda 表达式
    thread t3 {g,ref(vec3),&res3};       // 普通函数

    t1.join();
    t2.join();
    t3.join();

    cout << res1 << ' ' << res2 << ' ' << res3 << '\n';
}
```

类型安全库支持的设计主要依赖变参模板（[§4.3.2](#432-变参模板)）。例如，`std::thread` 的构造函数就是变参模板。它可以区分不同的可执行的第一个参数，并检查它们后面是否跟有正确数量正确类型的参数。

类似地，lambda 表达式（[§4.3.1](#431-lambda-表达式)）使 `<thread>` 库的许多使用变得更加简单。例如，`t2` 的参数是访问周围局部作用域的一段代码（lambda 表达式）。

线程和锁模型需要使用某种形式的同步来避免竞争条件。C++11 为此提供了标准的 `mutex`（互斥锁）：

```cpp
mutex m;  // 控制用的互斥锁
int sh;   // 共享的数据

void access ()
{
    unique_lock<mutex> lck {m};   // 得到互斥锁
    sh += 7;                      // 操作共享数据
} // 隐式释放互斥锁
```

`unique_lock` 是一个 RAII 对象，确保用户不会忘记在这个 `mutex` 上调用 `unlock()`。

这些锁对象还提供了一种防止最常见形式的死锁的方法：

```cpp
void f()
{
    // ...
    unique_lock<mutex> lck1 {m1,defer_lock};  // 还未得到 m1
    unique_lock<mutex> lck2 {m2,defer_lock};
    unique_lock<mutex> lck3 {m3,defer_lock};
    // ...
    lock(lck1,lck2,lck3);  // 获取所有三个互斥锁
    // ... 操作共享数据 ...
}   // 隐式释放所有互斥锁
```

这里，`lock()` 函数“同时”获取所有 `mutex` 并隐式释放所有互斥锁（RAII（[§2.2.1](02.md#221-语言特性)））。C++17 有一个更优雅的解决方案（[§8.4](08.md#84-并发)）。

最大的争议是关于取消操作，即阻止线程运行完成的能力。

### 4.1.3 期值（future）

C++11 提供了：

- `future`——一个句柄，通过它你可以从一个共享的单对象缓冲区中 `get()` 一个值，可能需要等待某个 `promise` 将该值放入缓冲区。
- `promise`——一个句柄，通过它你可以将一个值 `put()` 到一个共享的单对象缓冲区，可能会唤醒某个等待 `future` 的 `thread`。
- `packaged_task`——一个类，它使得设置一个函数在线程上异步执行变得容易，由 `future` 来接受 `promise` 返回的结果。
- `async()`——一个函数，可以启动一个任务并在另一个 `thread` 上执行。

使用这一切的最简单方法是使用 `async()`。给定一个普通函数作为参数，`async()` 在一个 `thread` 上运行它，处理线程启动和通信的所有细节：

```cpp
double comp4(vector<double>& v)
// 如果 v 足够大则会产生多个任务
{
    if (v.size()<10000)    // 值得用并发机制吗？
        return accum(v.begin(),v.end(),0.0);
    auto v0 = &v[0];
    auto sz = v.size();

    auto f0 = async(accum,v0,v0+sz/4,0.0);         // 第一部分
    auto f1 = async(accum,v0+sz/4,v0+sz/2,0.0);    // 第二部分
    auto f2 = async(accum,v0+sz/2,v0+sz*3/4,0.0);  // 第三部分
    auto f3 = async(accum,v0+sz*3/4,v0+sz,0.0);    // 第四部分

    return f0.get()+f1.get()+f2.get()+f3.get();    // 收集结果
}
```

`async` 将代码包装在 `packaged_task` 中，并管理 `future` 及其传输结果的 `promise` 的设置。

值或异常都可以通过这样一对 `future`/`promise` 从一个 `thread` 传递到另一个 `thread`。例如：

```cpp
X f(Y); // 普通函数

void ff(Y y, promise<X>& p)     // 异步执行 f(y)
{
    try {
        X res = f(y);           // ... 给 res 计算结果 ...
        p.set_value(res);
    }
    catch (...) {               // 哎呀：没能计算出 res
        p.set_exception(current_exception());
    }
}
```

为简单起见，我没有使用参数的完美转发（[§4.2.3](#423-移动语义)）。

对应 `future` 的 `get()` 现在要么得到一个值，要么抛出一个异常——与 `f()` 的某个等效同步调用完全一样。

```cpp
void user(Y arg)
{
    auto pro = promise<X>{};
    auto fut = pro.get_future();
    thread t {ff,arg,ref(pro)}; // 在不同线程上运行 ff
    // ... 做一会别的事情 ...
    X x = fut.get();
    cout << x.x << '\n';
    t.join();
}

int main()
{
    user(Y{99});
}
```

## 4.2 C++11：简化使用

### 4.2.1 `auto` 和 `decltype`

`auto` 是一个方便的静态特性，它允许从初始化表达式中推导出对象的静态类型。如果要用动态类型的变量，应该使用 `variant` 或者 `any`（[§8.3](08.md#83-variantoptional-和-any)）。

我们要在某些场景中把引用的类型也推导为一个引用。这在基于模板的基础库中并不少见。我们提出了用 `decltype` 运算符来处理这种保留引用的语义：

```cpp
template<typename T> void f(T& r)
{
    auto v = r;            // v 是 T
    decltype(r) r2 = r;    // r2 是 T&
    // ...
}
```

为什么是 `decltype`？可惜，我已经不记得是谁建议了这个名字了，但是我还记得原因：

- `typeof` 已经不能用了，因为那样会破坏很多老代码
- 我们找不到其他优雅、简短、且没有被用过的名字了
- `decltype` 足够好记（“declared type”的简写）；但也足够古怪，因而没有在现有代码中用过
- `decltype` 还算比较短

我收到了很多评论，说当人们将它和没有明显类型的初始化表达式放一起使用时可读性不好。因此，**C++ 核心指南** [Stroustrup and Sutter 2014–2020]（[§10.6](10.md#106-编码指南)）有了这条规则：

> ES.11：使用 `auto` 来避免类型名称的多余重复

我的书 [Stroustrup 2013, 2014d] 中也有类似的建议。考虑下面的例子：

```cpp
auto n = 1;  // 很好：n 是 int
auto x = make_unique<Gadget>(arg);  // 很好：x 是 std::unique_ptr<Gadget>
auto y = flopscomps(x,3);           // 不好：flopscomps() 返回的是啥东西？
```

### 4.2.2 范围 `for`

范围 `for` 是用来顺序遍历一个序列中所有元素的语句。例如：

```cpp
void use(vector<int>& v, list<string>& lst)
{
    for (int x : v) cout << x << '\n';
    int sum = 0;
    for (auto i : {1,2,3,5,8}) sum+=i; // 初始化列表是一个序列
    for (string& s : lst) s += ".cpp"; // 使用引用允许遍历时修改
}
```

### 4.2.3 移动语义

用户在按值返回“大对象”时，需要确保绝不会进行大量的数据复制。

要做到这一点，需要观察到“大对象”通常是在自由存储区上的数据的一个句柄。为了避免复制大量的数据，我们只需要确保在实现返回时，构造函数复制的只是句柄，而不是所有元素。C++11 对这个问题的解决方案如下所示：

```cpp
class Matrix {
    double* elements;    // 指向所有元素的指针
    // ...
public:
    Matrix (Matrix&& a)  // 移动构造
    {
        elements = a.elements;  // 复制句柄
        a.elements = nullptr;   // 现在 a 的析构函数不用做任何事情了
    }
    // ...
};
```

当用于初始化或赋值的源对象马上就会被销毁时，**移动**就比**拷贝**要更好：移动操作只是简单地把对象的内部表示“窃取”过来。`&&` 表示构造函数是一个**移动构造函数**，`Matrix&&` 被称为**右值引用**。当用于模板参数时，右值引用的符号 `&&` 被叫做**转发引用**，这是由 John Spicer 在 2002 年的一次会议上，同 Dave Abrahams 和 Howard Hinnant 一起提出的。

移动语义蕴含着性能上的重大好处：它消除了代价高昂的临时变量。例如：

```cpp
Matrix mx = m1+m2+m3;  // 不需要临时变量
string sx = s1+s2+s3;  // 不需要临时变量
```

> 右值引用可以用于给现有类方便地添加移动语义。意思是说，拷贝构造函数和赋值运算符可以根据实参是左值还是右值来进行重载。当实参是右值时，类的作者就知道他拥有对该实参的唯一引用。

一个突出的例子是生成“智能指针”的工厂函数：

```cpp
template <class T, class A1>
std::shared_ptr<T> factory(A1&& a1)
{
    return std::shared_ptr<T>(new T(std::forward<A1>(a1)));
}
```

移动语义技术就被应用到了标准库的所有容器类上，像 `vector`、`string` 和 `map`。`shared_ptr` 和 `unique_ptr` 的确智能，但它们仍然是指针。我更喜欢强调移动构造和移动赋值，它们使得（以句柄表示的）大型对象在作用域间能够高效移动。

### 4.2.4 资源管理指针

C++11 提供了“智能指针”（[§4.2.4](#424-资源管理指针)）：

- `shared_ptr`——代表共享所有权
- `unique_ptr`——代表独占所有权（取代 C++98 中的 `auto_ptr`）

```cpp
shared_ptr<Blob> make_Blob(Args a)
{
    auto p = shared_ptr<Blob>(new Blob(a));
    // ... 把很多好东西填到 *p ...
    return p;
}
```

当把对象移出函数时，引用计数会从 1 变到 2 再变回 1。在多线程程序中，这通常是涉及到同步的缓慢操作。另外，粗率地使用和/或实现引用计数，会增加分配和回收的开销。

正如预期的那样，`shared_ptr` 很快就流行起来，并在有些地方被严重滥用。因此，后来我们提供了不引入额外开销的 `unique_ptr`。`unique_ptr` 对它所指的对象拥有独占的所有权，并会在自身被销毁的时候把指向的对象也简单地 `delete` 掉。

```cpp
unique_ptr<Blob> make_Blob(Args a)
{
    auto p = unique_ptr<Blob>(new Blob(a));
    // ... 把很多好东西填到 *p ...
    return p;
}
```

显式使用 `new` 和 `delete` 的旧方式容易出错，在现代 C++ 中已经不推荐使用（例如，C++ 核心指南（[§10.6](10.md#106-编码指南)））。现在我们可以这样写：

```cpp
void newer_use(Args a)
{
    auto p = unique_ptr<Blob>(new Blob(a));
    // ...
    if (foo) throw Bad();  // 不会泄漏
    if (bar) return;       // 不会泄漏
    // ...
}
```

这种写法更简短、更安全，迅速就流行开去。不过，“智能指针”仍然被过度使用：“它们的确智能，但它们仍然是指针。”除非我们确实需要指针，否则，简单地使用局部变量会更好：

```cpp
void simplest_use(Args a)
{
    Blob b(a);
    // ...
    if (foo) throw Bad(); // 不会泄漏
    if (bar) return;      // 不会泄漏
    // ...
}
```

智能指针用于表示资源所有权的主要用途是面向对象编程，其中指针（或引用）用于访问对象，而对象的确切类型在编译时并不知道。

### 4.2.5 统一初始化

花括号（`{}`）对于单个值是可选的，并且花括号初始化器列表之前的 `=` 也是可选的。为了统一起见，在许多 C++98 不允许使用花括号或者 `=` 初始化的地方都接受花括号样式的初始化：

```cpp
int f(vector<int>);
int i = f({1,2,3});  // 函数参数

struct X {
    vector<int> v;
    int a[];
    X() : v{1,2}, a{3,4} {}  // 成员初始化器
    X(int);
    // ...
}

vector<int>* p = new vector<int>{1,2,3,4};  // new 表达式
X x {};  // 默认初始化

template<typename T> int foo(T);
int z = foo(X{1});  // 显式构造
```

在构造函数中进行选择时优先选择初始化器列表解释。这使 `vector<int> v2 {10}` 成为具有一个元素的 `vector`，并且使 `{…}` 初始化器的解释保持一致。但是，当我们想要避免使用初始化器列表构造函数时，这就迫使我们使用 `(…)` 写法。

### 4.2.6 `nullptr`

在 C 和 C++ 中，如果将字面量 `0` 赋值给指针或与指针比较时它表示空指针。更令人困惑的是，如果将任何求值为零的整数常量表达式赋值给指针或与指针比较时它也表示空指针。例如：

```cpp
int* p = 99-55-44; // 空指针
int* q = 2;        // 错误：2 是一个 int，而不是一个指针
```

现在我们可以说：

```cpp
int p0 = nullptr;
int* p1 = 99-55-44;  // 可以，为了兼容性
int* p2 = NULL;      // 可以，为了兼容性

int f(char*);
int f(int);

int x1 = f(nullptr); // f(char*)
int x2 = f(0);       // f(int)
```

### 4.2.7 `constexpr` 函数